<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/world.js | picoes</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Pico Entity System for JavaScript"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="picoes"><meta property="twitter:description" content="Pico Entity System for JavaScript"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ayebear/picoes"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity.js~Entity.html">Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/world.js~World.html">World</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/world.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { Entity } from &apos;./entity.js&apos;
import { SystemStorage } from &apos;./system_storage.js&apos;
import { EntityStorage } from &apos;./entity_storage.js&apos;

/**
 * Class for world.
 *
 * @class World (name)
 */
export class World {
  /**
   * Constructs an instance of the world.
   *
   * @param {object} [options] - The initial systems, components, and context to setup in the world.
   * Each one is optional. See below for registering these after world construction.
   *
   * @example
   * const world = new World({
   *   components: { position, velocity },
   *   systems: [Input, Physics, Render],
   *   context: { state },
   * })
   */
  constructor(options) {
    /** @ignore */
    this.systems = new SystemStorage(this)
    /** @ignore */
    this.entities = new EntityStorage(this)

    // Register components, context, and systems
    if (options) {
      if (options.components) {
        for (const name in options.components) {
          this.component(name, options.components[name])
        }
      }
      if (options.context) {
        this.context(options.context)
      }
      if (options.systems) {
        for (const systemClass of options.systems) {
          this.system(systemClass)
        }
      }
    }
  }

  /**
   * Removes all entities from the world.
   * Does not affect any registered systems or components.
   *
   * @example
   * world.clear()
   */
  clear() {
    this.entities.clear()
  }

  /**
   * Registers a component type to the world. Components must be constructable. If the component has
   * an onCreate(), it is passed all of the arguments from methods like entity.set(). Also, components
   * can have an onRemove() method, which gets called when removing that component from an entity.
   *
   * @param {string}   name           - The name
   * @param {function} componentClass - The component class, must be a constructable class or function
   *
   * @example
   * world.component(&apos;myComponent&apos;, class {
   *     // It is highly recommended to use onCreate() over constructor(), because the component
   *     // will have already been added to the entity. In the constructor(), it is not safe to use
   *     // &quot;entity&quot; because it does not contain the current component while still in the constructor.
   *     onCreate(some, args) {
   *         this.some = some
   *         this.args = args
   *         this.entity.set(&apos;whatever&apos;) // this.entity is auto-injected, and this is safe to do here
   *     }
   * })
   * // entity === the new entity object
   * // some === 10
   * // args === 500
   * world.entity().set(&apos;myComponent&apos;, 10, 500)
   *
   * @return {string} Registered component name on success, undefined on failure
   */
  component(name, componentClass) {
    this.entities.registerComponent(name, componentClass)
  }

  /**
   * Creates a new entity in the world
   *
   * @example
   * world.entity()
   *
   * @return {Entity} The new entity created
   */
  entity() {
    return this.entities.createEntity()
  }

  /**
   * Sets a context object that is automatically injected into all existing and new systems.
   * Calling this multiple times will overwrite any previous contexts passed. One caveat is that
   * you can only start to use the injected context in systems starting with init(). It is not
   * available in the constructor.
   *
   * @param {Object} data - The object to use as context to pass to systems.
   * All the keys inside the context object will be spread into the top-level of the system.
   *
   * @example
   * const state = { app: new PIXI.Application() }
   * const world = new World()
   * world.context(state) // new and existing systems can directly use this.app
   * world.system(...)
   *
   * @return {Entity} The new entity created
   */
  context(data) {
    this.systems.setContext(data)
  }

  /**
   * Registers a system to the world.
   * The order the systems get registered, is the order then run in.
   *
   * @example
   * // Movement system (basic example)
   * class MovementSystem {
   *   run(dt) {
   *     world.each(&apos;position&apos;, &apos;velocity&apos;, ({ position, velocity }) =&gt; {
   *       position.x += velocity.x * dt
   *       position.y += velocity.y * dt
   *     })
   *   }
   * }
   * // Input system (advanced example)
   * class InputSystem {
   *   init(key) {
   *     // Have access to this.keyboard here, but not in constructor
   *     this.key = key
   *   }
   *   run(dt) {
   *     if (this.keyboard.isPressed(this.key)) {
   *       world.each(&apos;controlled&apos;, &apos;velocity&apos;, ({ velocity }, entity) =&gt; {
   *         // Start moving all controlled entities to the right
   *         velocity.x = 1
   *         velocity.y = 0
   *         // Can also use the full entity here, in this case to add a new component
   *         entity.set(&apos;useFuel&apos;)
   *       })
   *     }
   *   }
   * }
   * // Inject context (see world.context())
   * world.context({ keyboard: new Keyboard() })
   * // Register systems in order (this method)
   * world.system(InputSystem, &apos;w&apos;) // pass arguments to init/constructor
   * world.system(MovementSystem)
   * // Run systems (can get dt or frame time)
   * world.run(1000.0 / 60.0)
   *
   * @param {Function} systemClass - The system class to instantiate. Can contain a
   * constructor(), init(), run(), or any other custom methods/properties.
   *
   * @param {...Object} [args] - The arguments to forward to the system&apos;s constructor and init.
   * Note that it is recommended to use init if using context, see world.context().
   * Passing args here is still useful, because it can be specific to each system, where
   * the same context is passed to all systems.
   */
  system(systemClass, ...args) {
    this.systems.register(systemClass, ...args)
  }

  /**
   * Calls run() on all systems. These methods can return true to cause an additional rerun of all systems.
   * Reruns will not receive the args passed into run(), as a way to identify reruns.
   *
   * @example
   * world.run(deltaTime)
   *
   * @example
   * // Example flow of method call order:
   * // Setup systems:
   * world.system(systemA)
   * world.system(systemB)
   * // During world.run():
   * // systemA.run()
   * // systemB.run()
   *
   * @param {...Object} [args] - The arguments to forward to the systems&apos; methods
   */
  run(...args) {
    this.systems.run(...args)
  }

  /**
   * Iterate through components and entities with all of the specified component names
   *
   * @example
   * // Use a callback to process entities one-by-one
   * // This is the recommended way, as it is higher performance than allocating and
   * // returning an array
   * world.each(&apos;comp&apos;, ({ comp }) =&gt; { comp.value = 0 })
   *
   * @example
   * // Get an array of entities
   * const entities = world.each(&apos;comp&apos;)
   * for (const entity of entities) {...}
   *
   * @example
   * // Pass multiple components, arrays, use extra entity parameter,
   * // and destructure components outside the query
   * world.each(&apos;compA&apos;, [&apos;more&apos;, &apos;comps&apos;], &apos;compB&apos;, ({ compA, compC }, entity) =&gt; {
   *   if (compC) compC.foo(compC.bar)
   *   compA.foo = &apos;bar&apos;
   *   entity.remove(&apos;compB&apos;)
   * })
   *
   * @param {...Object} args - Can pass component names, arrays of component names, and a callback,
   * in any order.
   *
   * **{...string}**: The component names to match entities with. This checks if the entity
   * has ALL of the specified components, but does not check for additional components.
   *
   * **{Function}**: The callback to call for each matched entity. Takes (entity.data, entity).
   * Entity data is an object of {[componentName]: [component]}, that can be destructured with syntax
   * shown in the examples.
   *
   * @return {Entity[]} If no callback is specified, then returns an array of the entity results.
   */
  each(...args) {
    return this.entities.each(...args)
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
